<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>所有文章 - William</title>
    <link>https://williamlfang.github.io/posts/</link>
    <description>所有文章 | William</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 10 Jul 2024 14:05:32 &#43;0800</lastBuildDate><atom:link href="https://williamlfang.github.io/posts/" rel="self" type="application/rss+xml" /><item>
  <title>init_shm 与 config 里面的 shm_size 大小需要保持一致</title>
  <link>https://williamlfang.github.io/2024-07-10-init_shm-%E4%B8%8E-config-%E9%87%8C%E9%9D%A2%E7%9A%84-shm_size-%E5%A4%A7%E5%B0%8F%E9%9C%80%E8%A6%81%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4/</link>
  <pubDate>Wed, 10 Jul 2024 14:05:32 &#43;0800</pubDate>
  <author>william</author>
  <guid>https://williamlfang.github.io/2024-07-10-init_shm-%E4%B8%8E-config-%E9%87%8C%E9%9D%A2%E7%9A%84-shm_size-%E5%A4%A7%E5%B0%8F%E9%9C%80%E8%A6%81%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4/</guid>
  <description><![CDATA[<p>今天遇到一个奇怪的现象：由于我们使用的 <code>init_shm</code> 清空共享内存数据，这个需要指定大小。由于初始化脚本事先不知道实际配置文件使用的 <code>shm_size</code>，导致两者的大小是不一样的。如此一来，<code>init_shm</code> 先是让操作系统分配了一个物理内存，然后使用的程序以配置文件的 <code>shm_size</code> 进行使用，导致内存越界了。</p>
<p>所以我们开发了专门用于交易运维的 <code>infra</code> 项目，通过自动化的方式进行匹配。</p>]]></description>
</item>
<item>
  <title>ubuntu 安装 sticky notes</title>
  <link>https://williamlfang.github.io/2024-07-10-ubuntu-%E5%AE%89%E8%A3%85-sticky-notes/</link>
  <pubDate>Wed, 10 Jul 2024 13:36:14 &#43;0800</pubDate>
  <author>william</author>
  <guid>https://williamlfang.github.io/2024-07-10-ubuntu-%E5%AE%89%E8%A3%85-sticky-notes/</guid>
  <description><![CDATA[<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo add-apt-repository ppa:umang/indicator-stickynotes
</span></span><span class="line"><span class="cl">sudo apt-get update
</span></span><span class="line"><span class="cl">sudo apt-get install indicator-stickynotes</span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item>
<item>
  <title>nvim 使用 sshfs 连接远程机器</title>
  <link>https://williamlfang.github.io/2024-07-08-nvim-%E4%BD%BF%E7%94%A8-sshfs-%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%BA%E5%99%A8/</link>
  <pubDate>Mon, 08 Jul 2024 18:44:47 &#43;0800</pubDate>
  <author>william</author>
  <guid>https://williamlfang.github.io/2024-07-08-nvim-%E4%BD%BF%E7%94%A8-sshfs-%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%BA%E5%99%A8/</guid>
  <description><![CDATA[<p><code>nvim</code> 可以通过调用 <code>sshfs</code>，把远程机器上面的文件映射到本地，进而使用本地的 <code>nvim</code> 进行查看与编辑。如此一来，即使远程机器没有安装 <code>nvim</code> 或者相关插件，我们一样也能丝滑地使用 <code>nvim</code> 了。</p>]]></description>
</item>
<item>
  <title>CTP 中文乱码解析</title>
  <link>https://williamlfang.github.io/2024-07-06-ctp-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E6%9E%90/</link>
  <pubDate>Sat, 06 Jul 2024 09:25:55 &#43;0800</pubDate>
  <author>william</author>
  <guid>https://williamlfang.github.io/2024-07-06-ctp-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E6%9E%90/</guid>
  <description><![CDATA[<div class="featured-image"><img loading="eager" src="https://williamlfang.github.io/2024-07-06-ctp-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E6%9E%90/tora.png" alt="CTP 中文乱码解析" title="CTP 中文乱码解析" referrerpolicy="no-referrer"/></div><p>有时我们在开发类 <code>CTP</code> 接口（如 CTP、TORA）等，会遇到中文消息乱码的现象，这是由于接口采用了 <code>GB10830</code> 等编码规范，无法直接在终端使用 <code>UTF8</code> 进行解析。因此，我们需要在接收层面进行解码，同时配置系统的解码标准。</p>]]></description>
</item>
<item>
  <title>nvim cmp</title>
  <link>https://williamlfang.github.io/2024-07-02-nvim-cmp/</link>
  <pubDate>Tue, 02 Jul 2024 11:57:10 &#43;0800</pubDate>
  <author>william</author>
  <guid>https://williamlfang.github.io/2024-07-02-nvim-cmp/</guid>
  <description><![CDATA[<p>使用 <code>nvim-cmp</code> 进行补全。</p>]]></description>
</item>
<item>
  <title>nvim keep fold on save</title>
  <link>https://williamlfang.github.io/2024-07-01-nvim-keep-fold-on-save/</link>
  <pubDate>Mon, 01 Jul 2024 22:27:20 &#43;0800</pubDate>
  <author>william</author>
  <guid>https://williamlfang.github.io/2024-07-01-nvim-keep-fold-on-save/</guid>
  <description><![CDATA[<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">vim.cmd</span><span class="p">(</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">augroup remember_folds
</span></span></span><span class="line"><span class="cl"><span class="s">    autocmd!
</span></span></span><span class="line"><span class="cl"><span class="s">    au BufWinLeave ?* mkview 1
</span></span></span><span class="line"><span class="cl"><span class="s">    au BufWinEnter ?* silent! loadview 1
</span></span></span><span class="line"><span class="cl"><span class="s">augroup END
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item>
<item>
  <title>nvim 从零开始</title>
  <link>https://williamlfang.github.io/2024-06-28-nvim-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</link>
  <pubDate>Fri, 28 Jun 2024 17:23:35 &#43;0800</pubDate>
  <author>william</author>
  <guid>https://williamlfang.github.io/2024-06-28-nvim-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</guid>
  <description><![CDATA[Ref 一份目录规范的nvim配置项目]]></description>
</item>
<item>
  <title>nvim 打开当前光标下文件</title>
  <link>https://williamlfang.github.io/2024-06-26-nvim-%E6%89%93%E5%BC%80%E5%BD%93%E5%89%8D%E5%85%89%E6%A0%87%E4%B8%8B%E6%96%87%E4%BB%B6/</link>
  <pubDate>Wed, 26 Jun 2024 20:09:05 &#43;0800</pubDate>
  <author>william</author>
  <guid>https://williamlfang.github.io/2024-06-26-nvim-%E6%89%93%E5%BC%80%E5%BD%93%E5%89%8D%E5%85%89%E6%A0%87%E4%B8%8B%E6%96%87%E4%BB%B6/</guid>
  <description><![CDATA[<p>有时我们需要临时配置或者修改文件，一般的做法是进入 <code>visual</code> 模式然后使用命令 <code>gf</code> 打开当前文件。这样的做法其实有点冗余，特别是当我们在线上排查问题时，希望能快速打开光标下的文件。</p>
<p>为此，我们可以定义一个函数，然后绑定快捷键即可迅速打开文件了</p>
<ul>
<li>
<p>定义一个函数 <code>JumpOrCreateFile</code></p>
<ul>
<li>可以自动识别文件路径</li>
<li>如果文件不存在，则提醒我们是否需要创建</li>
</ul>
</li>
<li>
<p>绑定快捷键 <code>gf</code> 方便操作</p>
</li>
</ul>
<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">vim.cmd</span><span class="p">(</span><span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">nnoremap &lt;silent&gt; gf :call JumpOrCreateFile()&lt;CR&gt;
</span></span></span><span class="line"><span class="cl"><span class="s">function! JumpOrCreateFile()
</span></span></span><span class="line"><span class="cl"><span class="s">    &#34; Get the filename under the cursor
</span></span></span><span class="line"><span class="cl"><span class="s">    let filename = expand(&#34;&lt;cfile&gt;&#34;)
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">    &#34;--------------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="s">    &#34; split to get filename path
</span></span></span><span class="line"><span class="cl"><span class="s">    if filename =~# &#39;:&#39;
</span></span></span><span class="line"><span class="cl"><span class="s">        let expanded_filename = expand(split(filename, &#34;:&#34;)[1])
</span></span></span><span class="line"><span class="cl"><span class="s">    elseif filename =~# &#39;,&#39;
</span></span></span><span class="line"><span class="cl"><span class="s">        let expanded_filename = expand(split(filename, &#34;,&#34;)[1])
</span></span></span><span class="line"><span class="cl"><span class="s">    elseif filename =~# &#39;=&#39;
</span></span></span><span class="line"><span class="cl"><span class="s">        let expanded_filename = expand(split(filename, &#34;=&#34;)[1])
</span></span></span><span class="line"><span class="cl"><span class="s">    else
</span></span></span><span class="line"><span class="cl"><span class="s">        let expanded_filename = expand(filename)
</span></span></span><span class="line"><span class="cl"><span class="s">    endif
</span></span></span><span class="line"><span class="cl"><span class="s">    &#34;--------------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">    &#34; Check if the file path starts with &#34;./&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">    if expanded_filename =~# &#39;^\.\/&#39;
</span></span></span><span class="line"><span class="cl"><span class="s">        &#34; Get the current directory of the editing file
</span></span></span><span class="line"><span class="cl"><span class="s">        let current_directory = expand(&#39;%:p:h&#39;)
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">        &#34; Create the full path by appending the relative file path
</span></span></span><span class="line"><span class="cl"><span class="s">        let expanded_filename = current_directory . &#39;/&#39; . expanded_filename
</span></span></span><span class="line"><span class="cl"><span class="s">    endif
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">    &#34; Check if the file exists
</span></span></span><span class="line"><span class="cl"><span class="s">    if !filereadable(expanded_filename)
</span></span></span><span class="line"><span class="cl"><span class="s">        &#34; Prompt the user for file creation with the full path
</span></span></span><span class="line"><span class="cl"><span class="s">        let choice = confirm(&#39;File does not exist. Create &#34;&#39; . expanded_filename . &#39;&#34;?&#39;, &#34;&amp;Yes\n&amp;No&#34;, 1)
</span></span></span><span class="line"><span class="cl"><span class="s">        &#34; Handle the user&#39;s choice
</span></span></span><span class="line"><span class="cl"><span class="s">        if choice == 1
</span></span></span><span class="line"><span class="cl"><span class="s">            &#34; Create the file and open it
</span></span></span><span class="line"><span class="cl"><span class="s">            echohl WarningMsg | echo &#39;Created New File: &#39; . expanded_filename | echohl None
</span></span></span><span class="line"><span class="cl"><span class="s">            execute &#39;edit &#39; . expanded_filename
</span></span></span><span class="line"><span class="cl"><span class="s">        endif
</span></span></span><span class="line"><span class="cl"><span class="s">    else
</span></span></span><span class="line"><span class="cl"><span class="s">        &#34; File exists, perform normal gf behavior
</span></span></span><span class="line"><span class="cl"><span class="s">        echohl ModeMsg | echo &#39;Open File: &#39; . expanded_filename | echohl None
</span></span></span><span class="line"><span class="cl"><span class="s">        &#34; execute &#39;normal! gf&#39;
</span></span></span><span class="line"><span class="cl"><span class="s">        execute &#39;edit &#39; . expanded_filename
</span></span></span><span class="line"><span class="cl"><span class="s">    endif
</span></span></span><span class="line"><span class="cl"><span class="s">endfunction
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item>
<item>
  <title>c&#43;&#43; hash map</title>
  <link>https://williamlfang.github.io/2024-06-22-c-hash-map/</link>
  <pubDate>Sat, 22 Jun 2024 17:01:52 &#43;0800</pubDate>
  <author>william</author>
  <guid>https://williamlfang.github.io/2024-06-22-c-hash-map/</guid>
  <description><![CDATA[<p>我们在组织不同信号、不同策略时，往往需要一个容器存放对应合约标识的容器。这个容器要求具有一定的扩展性（即事先无法知晓容器大小），具有良好的插入效率、以及较高性能的查找性能。对于一般的算法，我们直接使用标准库里的哈希容器即可，这包括 <code>std::unordered_map</code>。</p>
<p>然后，对于一个低延迟的交易系统，我们总是对性能有着极致的渴望，尽力开发性的数据容器，提升查找性能。</p>
<ul>
<li>
<ol>
<li>对于特化容器，如 <code>&lt;int, typename T&gt;</code>，可以更加快速的实现查找</li>
</ol>
</li>
<li>
<ol start="2">
<li>对于较大对象，如 <code>&lt;std::string, typename T&gt;</code>, 则尽量避免运行期的构造开销，例如在确认不同的合约标识肯定的唯一情况下，可以大胆使用类型转化，直接 <code>cast</code> 为 <code>int</code> 类型。</li>
</ol>
</li>
</ul>]]></description>
</item>
<item>
  <title>vim 支持中文解码</title>
  <link>https://williamlfang.github.io/2024-06-21-vim-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E8%A7%A3%E7%A0%81/</link>
  <pubDate>Fri, 21 Jun 2024 17:40:04 &#43;0800</pubDate>
  <author>william</author>
  <guid>https://williamlfang.github.io/2024-06-21-vim-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E8%A7%A3%E7%A0%81/</guid>
  <description><![CDATA[<div class="highlight" id="id-1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr</span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item>
</channel>
</rss>
